#!/usr/bin/env node
/**
 * Seed chapters into the database from content files
 *
 * Usage:
 *   node scripts/seed-chapters.mjs          # Output SQL to stdout
 *   node scripts/seed-chapters.mjs --run    # Run directly against Supabase
 */

import { readdir, readFile } from 'fs/promises';
import { join, basename } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import { load as loadYaml } from 'js-yaml';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const HTML_DIR = join(__dirname, '../content/html');
const CHAPTERS_YAML = join(__dirname, '../content/chapters.yaml');

/**
 * Generate a deterministic UUID from a chapter slug
 * Must match the slugToUUID function in the API route
 */
function slugToUUID(slug) {
  const namespace = 'c7b3d8e2-1f4a-5b6c-9d0e-a1b2c3d4e5f6';

  let hash = 0;
  const combined = namespace + slug;
  for (let i = 0; i < combined.length; i++) {
    const char = combined.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }

  const hex = Math.abs(hash).toString(16).padStart(8, '0');
  const fullHex = (hex + hex + hex + hex).substring(0, 32);
  return `${fullHex.substring(0, 8)}-${fullHex.substring(8, 12)}-${fullHex.substring(12, 16)}-${fullHex.substring(16, 20)}-${fullHex.substring(20, 32)}`;
}

/**
 * Extract title from HTML file
 */
function extractTitle(html) {
  const match = html.match(/<h1[^>]*>([^<]+)<\/h1>/);
  return match ? match[1].trim() : null;
}

/**
 * Escape single quotes for SQL
 */
function escapeSql(str) {
  return str ? str.replace(/'/g, "''") : null;
}

async function loadChaptersConfig() {
  try {
    const content = await readFile(CHAPTERS_YAML, 'utf-8');
    return loadYaml(content);
  } catch (error) {
    console.error('Failed to load chapters.yaml:', error.message);
    return null;
  }
}

async function getChapterData() {
  const config = await loadChaptersConfig();
  const chapters = [];

  if (config?.sections) {
    // Process chapters with order and section from YAML
    let order = 0;
    for (const section of config.sections) {
      for (const slug of section.chapters) {
        const htmlPath = join(HTML_DIR, `${slug}.html`);
        order++;

        try {
          const html = await readFile(htmlPath, 'utf-8');
          const title = extractTitle(html);
          const id = slugToUUID(slug);

          chapters.push({
            id,
            slug,
            title,
            chapter_order: order,
            section: section.name,
          });
        } catch (error) {
          console.error(`  Warning: Could not read ${slug}.html:`, error.message);
        }
      }
    }
  } else {
    // Fallback: no sections, just order by filename
    const files = await readdir(HTML_DIR);
    const slugs = files
      .filter(f => f.endsWith('.html') && !f.startsWith('.'))
      .map(f => basename(f, '.html'));

    let order = 0;
    for (const slug of slugs) {
      const htmlPath = join(HTML_DIR, `${slug}.html`);
      order++;

      try {
        const html = await readFile(htmlPath, 'utf-8');
        const title = extractTitle(html);
        const id = slugToUUID(slug);

        chapters.push({
          id,
          slug,
          title,
          chapter_order: order,
          section: null,
        });
      } catch (error) {
        console.error(`  Warning: Could not read ${slug}.html:`, error.message);
      }
    }
  }

  return chapters;
}

function generateSQL(chapters) {
  const lines = [
    '-- Auto-generated chapter seed data',
    '-- Generated by: node scripts/seed-chapters.mjs',
    '',
    '-- Upsert all chapters with their titles, order, and section',
  ];

  for (const chapter of chapters) {
    const title = chapter.title ? `'${escapeSql(chapter.title)}'` : 'NULL';
    const section = chapter.section ? `'${escapeSql(chapter.section)}'` : 'NULL';
    lines.push(
      `INSERT INTO chapters (id, slug, title, chapter_order, section) VALUES ('${chapter.id}', '${chapter.slug}', ${title}, ${chapter.chapter_order}, ${section}) ON CONFLICT (slug) DO UPDATE SET title = EXCLUDED.title, chapter_order = EXCLUDED.chapter_order, section = EXCLUDED.section;`
    );
  }

  return lines.join('\n');
}

async function runAgainstSupabase(chapters) {
  // Check for required env vars
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!supabaseUrl || !supabaseServiceKey) {
    console.error('Error: Missing NEXT_PUBLIC_SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY');
    console.error('Set these environment variables or use --sql to output SQL instead.');
    process.exit(1);
  }

  // Dynamic import to avoid issues if not installed
  const { createClient } = await import('@supabase/supabase-js');
  const supabase = createClient(supabaseUrl, supabaseServiceKey);

  console.log(`Seeding ${chapters.length} chapters...`);

  for (const chapter of chapters) {
    const { error } = await supabase
      .from('chapters')
      .upsert(
        {
          id: chapter.id,
          slug: chapter.slug,
          title: chapter.title,
          chapter_order: chapter.chapter_order,
          section: chapter.section,
        },
        { onConflict: 'slug' }
      );

    if (error) {
      console.error(`  Error seeding ${chapter.slug}:`, error.message);
    } else {
      console.log(`  âœ“ [${chapter.chapter_order}] ${chapter.slug}: ${chapter.title || '(no title)'} (${chapter.section})`);
    }
  }

  console.log('\nDone!');
}

async function main() {
  const args = process.argv.slice(2);
  const shouldRun = args.includes('--run');

  console.error('Loading chapter data...\n');
  const chapters = await getChapterData();
  console.error(`Found ${chapters.length} chapters\n`);

  if (shouldRun) {
    await runAgainstSupabase(chapters);
  } else {
    // Output SQL to stdout
    const sql = generateSQL(chapters);
    console.log(sql);
    console.error('\n-- To run directly against Supabase, use: node scripts/seed-chapters.mjs --run');
  }
}

main().catch(console.error);
